package generator

import (
	"bytes"
	"fmt"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/pkg/errors"
)

type paramInfo struct {
	Param     *Param
	Mapper    *Mapper
	Type      *TypeSpec
	FieldInfo *FieldInfo
}

type StructGenerator struct {
	message *Message

	typeName     string
	typeLetter   string
	flagTypeName string

	positionalParams []paramInfo
	namedParams      []paramInfo
}

func NewStructGenerator(message *Message) *StructGenerator {
	return &StructGenerator{
		message: message,
	}
}

func (s *StructGenerator) Generate() error {
	err := s.prepare()
	if err != nil {
		return err
	}

	file := s.generateFile()

	buf := bytes.NewBuffer(nil)
	file.Render(buf)

	fmt.Println(buf.String())

	return nil
}

func (s *StructGenerator) prepare() error {
	var err error

	s.positionalParams, err = s.prepareParams(s.message.PositionalParams)
	if err != nil {
		return err
	}

	s.namedParams, err = s.prepareParams(s.message.NamedParams)
	if err != nil {
		return err
	}

	s.typeName = s.message.Command + "Content"
	s.typeLetter = strings.ToLower(s.typeName[0:1])
	s.flagTypeName = s.message.Command + "Flag"

	return nil
}

func (s *StructGenerator) prepareParams(params []*Param) ([]paramInfo, error) {
	paramInfos := make([]paramInfo, 0, len(params))

	for _, param := range params {
		typeSpec, err := TypeSpecFromName(param.Type)
		if err != nil {
			return nil, errors.Wrapf(err, "type resolution failed for type name %s specified by "+
				"param %s of message %s", param.Name, s.message.Command)
		}
		mapper, err := ResolveMapperFromParam(param)
		if err != nil {
			return nil, errors.Wrapf(err, "mapper resolution failed for param %s of message %s "+
				"with type %s", param.Name, s.message.Command)
		}

		ctx := Context{
			Param:  param,
			Mapper: mapper,
			Type:   typeSpec,
		}

		paramInfos = append(paramInfos, paramInfo{
			Param:     param,
			Mapper:    mapper,
			Type:      typeSpec,
			FieldInfo: mapper.ComposeFieldInfo(&ctx),
		})
	}

	return paramInfos, nil
}

func (s *StructGenerator) generateFile() *jen.File {
	file := jen.NewFile("message")

	file.Comment("Code generated by adcl/protocol/generator. DO NOT EDIT.")

	file.Line()

	file.Type().Id(s.flagTypeName).String()

	if len(s.namedParams) > 0 {
		file.Const().
			DefsFunc(s.generateFlagConstants)
	}

	file.Var().Id("_").Id("ParamAccessor").Op("=").Op("&").Id(s.typeName).Values()

	file.Type().Id(s.typeName).StructFunc(s.generateStructFields)

	file.Func().Params(jen.Id(s.typeLetter).Op("*").Id(s.typeName)).
		Id("Positional").Params().Index().String().
		BlockFunc(s.generatePositional)

	file.Line()

	file.Func().Params(jen.Id(s.typeLetter).Op("*").Id(s.typeName)).
		Id("PosLen").Params().Int().
		BlockFunc(s.generatePosLen)

	file.Line()

	file.Func().Params(jen.Id(s.typeLetter).Op("*").Id(s.typeName)).
		Id("PosAt").Params(jen.Id("i").Int()).String().
		BlockFunc(s.generatePosAt)

	file.Line()

	file.Func().Params(jen.Id(s.typeLetter).Op("*").Id(s.typeName)).
		Id("Named").Params().Map(jen.String()).String().
		BlockFunc(s.generateNamed)

	file.Line()

	file.Func().Params(jen.Id(s.typeLetter).Op("*").Id(s.typeName)).
		Id("NamedGet").Params(jen.Id("key").String()).Params(jen.String(), jen.Bool()).
		BlockFunc(s.generateNamedGet)

	return file
}

func (s *StructGenerator) generateFlagConstants(group *jen.Group) {
	for ind, param := range s.namedParams {
		ctx := s.createContext(param)

		name := param.Mapper.Parser.Named.ParamName(&ctx)

		if ind == 0 {
			group.Id(s.flagTypeName + name).Id(s.flagTypeName).Op("=").Lit(name)
		} else {
			group.Id(s.flagTypeName + name).Op("=").Lit(name)
		}
	}
}

func (s *StructGenerator) generateStructFields(group *jen.Group) {
	s.generateParamsStructFields(group, s.positionalParams)
	s.generateParamsStructFields(group, s.namedParams)

	group.Id("Flags").Map(jen.String()).String()

	group.Line()

	if len(s.message.Flags) == 0 {
		group.Comment("No known additional flags.")
	} else {
		for _, flag := range s.message.Flags {
			group.Comment(flag.Comment)
		}
	}
}

func (s *StructGenerator) generateParamsStructFields(group *jen.Group, params []paramInfo) {
	for _, param := range params {
		info := param.FieldInfo

		// TODO: Format and insert comment

		group.Add(info.FieldName).Add(info.FieldType)

		strFieldType := jen.String()
		if !info.StrIsSingular {
			strFieldType = jen.Index().Add(strFieldType)
		}
		group.Add(info.StrFieldName).Add(strFieldType)

		group.Line()
	}
}

func (s *StructGenerator) generatePositional(group *jen.Group) {
	var numStatic int

	for _, param := range s.positionalParams {
		if param.FieldInfo.Multiplicity == MultiplicityStatic {
			numStatic++
		}
	}

	if numStatic == len(s.positionalParams) {
		// All params have static multiplicity, build slice literal.

		group.Return(
			jen.Index().String().ValuesFunc(func(group *jen.Group) {
				for _, param := range s.positionalParams {
					if param.FieldInfo.StrIsSingular {
						group.Id(s.typeLetter).Dot("").Add(param.FieldInfo.StrFieldName)
					} else {
						for i := 0; i < param.FieldInfo.StaticMultiplicity; i++ {
							group.Id(s.typeLetter).Dot("").Add(param.FieldInfo.StrFieldName).
								Index(jen.Lit(i))
						}
					}
				}
			}),
		)
	} else if numStatic == 0 && len(s.positionalParams) == 1 {
		// There is only a single, dynamic multiplicity param, return its str
		// field.

		group.Return(
			jen.Id(s.typeLetter).Dot("").Add(s.positionalParams[0].FieldInfo.StrFieldName),
		)
	} else {
		// Params have mixed multiplicity, build slice of positionals
		// manually.

		group.Id("positionals").Op(":=").Make(
			jen.Index().String(),
			jen.Lit(0),
			jen.Id(s.typeLetter).Dot("PosLen").Call(),
		)

		for _, param := range s.positionalParams {
			if param.FieldInfo.StrIsSingular {
				group.Id("positionals").Op("=").Append(
					jen.Id("positionals"),
					jen.Id(s.typeLetter).Dot("").Add(param.FieldInfo.StrFieldName),
				)
			} else if param.FieldInfo.Multiplicity == MultiplicityStatic {
				group.Id("positionals").Op("=").AppendFunc(func(group *jen.Group) {
					group.Id("positionals")
					for i := 0; i < param.FieldInfo.StaticMultiplicity; i++ {
						group.Id(s.typeLetter).Dot("").Add(param.FieldInfo.StrFieldName).
							Index(jen.Lit(i))
					}
				})
			} else {
				group.Id("positionals").Op("=").Append(
					jen.Id("positionals"),
					jen.Id(s.typeLetter).Dot("").Add(param.FieldInfo.StrFieldName).Op("..."),
				)
			}
		}

		group.Return(jen.Id("positionals"))
	}
}

func (s *StructGenerator) generatePosLen(group *jen.Group) {
	var staticSum int
	var stmt jen.Statement

	for _, param := range s.positionalParams {
		ctx := s.createRenderingContext(param)

		if param.FieldInfo.Multiplicity == MultiplicityStatic {
			staticSum += param.FieldInfo.StaticMultiplicity
		} else {
			stmt.Op("+").Add(param.FieldInfo.DynamicMultiplicity(&ctx))
		}
	}

	if staticSum > 0 || len(stmt) == 0 {
		group.Return(jen.Lit(staticSum).Add(&stmt))
	} else {
		// Remove first Op("+")
		stmt = stmt[1:]
		group.Return(&stmt)
	}
}

func (s *StructGenerator) generatePosAt(group *jen.Group) {
}

func (s *StructGenerator) generateNamed(group *jen.Group) {
}

func (s *StructGenerator) generateNamedGet(group *jen.Group) {
}

func (s *StructGenerator) createRenderingContext(param paramInfo) RenderingContext {
	return RenderingContext{
		Context:    s.createContext(param),
		ContentVar: jen.Id(s.typeLetter),
		FieldInfo:  param.FieldInfo,
	}
}

func (s *StructGenerator) createContext(param paramInfo) Context {
	return Context{
		Param:  param.Param,
		Mapper: param.Mapper,
		Type:   param.Type,
	}
}
